# Windows非同期版パフォーマンス問題の記録

記録日: 2025年1月8日

## 問題の概要

Windows環境でClaude CLI MCP Serverを非同期実行（asyncio）に統一した際、極端なパフォーマンス低下が発生しました。

## 発生した問題

### パフォーマンス測定結果

同期版（subprocess.run）と非同期版（asyncio.create_subprocess_exec）の実行時間比較：

**同期版（正常）**:
- 通常のクエリ: 8-10秒

**非同期版（問題あり）**:
- セッションリセット後の初回実行: 100.25秒
- 「Windowsの歴史について」クエリ: 277.90秒
- その後の「こんにちは」: 31.43秒

約10-30倍の性能劣化が確認されました。

## 原因分析

Geminiとの相談により、以下の原因が判明：

1. **WSL仮想化レイヤーとasyncioの相性問題**
   - `proc.communicate()`がWSLとのI/Oパイプ処理で非効率的なブロッキングを引き起こす
   - PythonのイベントループとWSLプロセス間の標準入出力のやり取りが詰まる

2. **MCPサーバーの特性**
   - MCPサーバーは1対1通信モデル（1サーバー = 1クライアント）
   - 並行処理の必要がないため、非同期化のメリットが活かせない
   - むしろ同期版の方がシンプルで高速

## 解決策

Windows環境では同期版（subprocess.run）を使用することに決定：
- 安定して高速（8-10秒）
- コードがシンプルで保守しやすい
- MCPの1対1通信モデルに適している

WSL/Unix環境では非同期版を継続使用：
- stdin継承問題は解決済み（stdin=asyncio.subprocess.DEVNULL）
- 正常に動作している

## 教訓

1. 理論的に優れた実装（非同期）が、実環境では必ずしも最適とは限らない
2. WSL経由の処理では、Pythonのasyncioとの相性問題に注意が必要
3. プラットフォームごとの最適化が重要
4. MCPサーバーの1対1通信特性を考慮した実装選択が必要

## 参考情報

- テスト結果: `/test/test_windows版_nosync_結果.txt`
- Geminiとの相談記録: `/doc/gemini_code_review_20250108.md`